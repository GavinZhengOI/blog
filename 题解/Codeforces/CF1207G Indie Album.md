# CF1207G Indie Album

一道很有意思的AC自动机好题。

AC自动机的本质是记录了一棵字典树上所有字符串的所有后缀，所以这道题我们可以充分利用这个性质。

这道题与板子题的不同之处就在于：文本串在不停的变化，每次增加一个字符。

我们先来复习一下AC自动机模版题的流程

1. 遍历文本串的所有前缀。
2. 将所有是这个前缀的后缀的模式串出现次数+1。（即沿着fail指针一直走到根，沿途的所有节点都是符合条件的）

而对于这道题，因为文本串每次只会添加一个字符。所以我们在上一个文本串的基础上，加入以当前节点到根组成的字符串的贡献即可。

那这道题的解决方案就比较清晰了：

我们将字符串$s$定义为当前字典树节点到根的所有节点组成的字符串，文本串$s$对应的模式串出现次数的记为$t[s]$，将文本串$s$对应的答案记为$ans[s]$

1. 建出一个文本串组成的字典树。
2. 对字典树进行DFS，每走到一个节点，将所有为s后缀的字符串的出现次数$t$加1。
3. 记录答案$ans[s]=t[s]$。
4. DFS回溯时，将所有为s后缀的字符串的出现次数$t$减1。

因为所有字符串长度和$T$的大小关系，$T^2$算法是过不了的。但是因为累计答案是在$fail$指针构成的树，所以我们可以用数据结构来维护这个东西。复杂度变成了$T\log T$。

个人感觉这道题的关键在于利用AC自动机“求解单文本串问题时会遍历文本串的所有前缀”这个性质，从而求解特殊的多文本串问题。