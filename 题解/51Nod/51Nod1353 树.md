# 51Nod1353 树

## 思路

我们定义$dp[i][j]$代表第`i`个点联通块大小为`j`的方案总数，也可以把它理解为等待分配（不确定归属）的联通块大小为`j`的方案总数。

那么每次转移我们就使用一个类似背包的东西来统计答案。

对于一个节点的每个儿子，我们只需要从大到小遍历所有可用的`j_now`（`j_now`上限就是所有遍历过的点子树大小的和）。然后再枚举这个儿子的`j_son`，那么显然我们就获得了很多第`i`个点联通块大小为`j_son+j_now`的方案。`dp[i][j_son+j_now]+=dp[i][j_now]*dp[son][j_son]`累计一下答案即可。需要注意的是，`j_now`需要从大往小遍历，因为反过来的话方案会算重（自己想一下01背包和完全背包）。另外，`j_son`是可以为0的，`dp[son][0]`代表`son`这个点只会包含在`son`子树内的联通块。所以对于每一个`j_now`都需要`dp[now][j_now]*=dp[son][0]`。

在状态转移完后，对于每一个$j\geq k$我们都要执行操作`dp[now][0]+=dp[now][j]`。相当于分了一块大小为`j`的联通块。想一想就知道为什么了。

