# [BZOJ1901]Zju2112 Dynamic Rankings	

## Description

给定一个含有n个数的序列a[1],a[2],a[3]……a[n]，程序必须回答这样的询问：对于给定的i,j,k，在a[i],a[i+1

],a[i+2]……a[j]中第k小的数是多少(1≤k≤j-i+1)，并且，你可以改变一些a[i]的值，改变后，程序还能针对改

变后的a继续回答上面的问题。

## Input

第一行有两个正整数n(1≤n≤10000)，m(1≤m≤10000)。

分别表示序列的长度和指令的个数。

第二行有n个数，表示a[1],a[2]……a[n]，这些数都小于10^9。

接下来的m行描述每条指令

每行的格式是下面两种格式中的一种。 

Q i j k 或者 C i t 

Q i j k （i,j,k是数字，1≤i≤j≤n, 1≤k≤j-i+1）

表示询问指令，询问a[i]，a[i+1]……a[j]中第k小的数。

C i t (1≤i≤n，0≤t≤10^9)表示把a[i]改变成为t

m,n≤10000

## Output

 对于每一次询问，你都需要输出他的答案，每一个输出占单独的一行。

## Sample Input

5 3
3 2 1 4 7
Q 1 4 3
C 2 6
Q 2 5 3


## Sample Output

3

6

## 思路

一道经典的树套树（树状数组套主席树）。

首先，如果不做修改，这是道标准的主席树模板题。

因为在这道题中主席树是用前缀和的方式存储的。所以当我们修改点$i$时，我们还需要修改$[i+1,n]$。这样就使得复杂度变得无法接受。

于是我们考虑使用套一层树状数组的方式来解决。假设在一般的树状数组中$c[i]=\sum _{i=l}^{r} a[i]$，那么在树套树中$c[i]$这个点就是一棵包含$[l,r]$这个区间的权值线段树（主席树）。这样在修改时，只需要修改lowbit上的$\log _2n$棵线段树。

在求和时我们只需要按照树状数组的求和方式来求出总和即可。

注意，每个树状数组节点上的主席树都是独立的。