# 动态更新-算法模版合集

## 图论

### 最大流

```cpp
int s=1995,t=1996;
struct gg {
    int u,v,w,next;
}side[maxn*2];
int head[maxn],cnt=1,maxflow,cur[maxn],rk[maxn];
using namespace std;
void insert(int u,int v,int w) {
    struct gg a={u,v,w,head[u]};side[++cnt]=a;head[u]=cnt;
};
bool bfs() {
    memset(rk,0,sizeof(rk));rk[s]=1;
    queue<int>q;q.push(s);
    while(!q.empty()) {
        int now=q.front();q.pop();
        for(int i=head[now];i;i=side[i].next) {
            int v=side[i].v,w=side[i].w;//w为容量
            if(!w||rk[v])continue;
            rk[v]=rk[now]+1;
            q.push(v);
        }
    }
    if(rk[t])return 1;//走得到
    return 0;
}
int dfs(int now,int flow) {//flow为上一个点能传到这里的流量
    if(now==t)return flow;
    int tot=0;
    for(int &i=cur[now];i;i=side[i].next) {//当前弧优化
        int v=side[i].v,w=side[i].w;
        if(!w||rk[v]!=rk[now]+1)continue;
        int sent=dfs(v,min(flow,w));//sent为当前增广的流量
        tot+=sent;//累计答案
        flow-=sent;side[i].w-=sent;side[i^1].w+=sent;//更新残余网络
    }
    return tot;
}
void dinic() {
    while(bfs()) {
        memcpy(cur,head,sizeof(head));//当前弧优化
        maxflow+=dfs(s,inf);
    }
}
```

### 单源最短路

```cpp
struct cop{
    bool operator()(po x,po y){
        return x.dis>y.dis;
    }
};
po mk(int num,int dis){
    po sent;sent.num=num;sent.dis=dis;
    return sent;
}
priority_queue<po,vector<po>,cop>line;
int head[maxn];
bool check[maxn]={0};
int main(){
    for(int i=0;i<=n+10;i++) dis[i]=inf;
    dis[s]=0;
    line.push(mk(s,0));
    while(!line.empty()){
        po a=line.top();line.pop();
        int now=a.num;
       if(a.dis>dis[a.num])continue;
        int point=head[now];
        while(point){
            int u=side[point].s;
            int v=side[point].e;
            int w=side[point].w;
            if(dis[u]+w<dis[v]){
                dis[v]=dis[u]+w;
                
                line.push(mk(v,dis[v]));
            }
            point=side[point].next;
        }
    }
    return 0;
}
```

